<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DFS/BFS</title>
    <link rel="stylesheet" href="code-style.css">
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="option.js"></script>
</head>

<body>
    <p style="text-align: left;">
        <a href="index.html">topページ</a>
    </p>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.4/css/all.css">
    <div id="page_top"><a href="#"></a></div>
    <pre>
    <code class="prettyprint linenums">
        //TIMESTAMPbfs
        vector&lt;bool&gt; seen;
        vec first;
        vec last;
        void dfs(const Graph &amp;G, ll v, ll &amp;time)
        {
            if (!(seen[v]))
            {
                seen[v] = true;
                first[v] = time++;
                for (auto next_v : G[v])
                {
                    if (seen[next_v])
                        continue;
                    dfs(G, next_v, time);
                }
                last[v] = time++;
            }
        }
        //main関数内で
        seen.assign(n, false); // 全頂点を「未訪問」に初期化
        first.resize(n);
        last.resize(n);
        ///////////////////////////////////////////////////////////////////////////
        field.assign(h, vector&lt;ll&gt;(w, 0));
        vector&lt;vector&lt;ll&gt;&gt; field;
        void dfs(ll x, ll y, ll h, ll w)
        {
            field[x][y] = 0;
            loop(i, 8)
            {
                ll next_x = x + dx[i], next_y = y + dy[i];
                if (next_x &lt; 0 || next_x &gt;= h || next_y &lt; 0 || next_y &gt;= w)
                    continue;
                if (field[next_x][next_y] == 0)
                    continue;
                dfs(next_x, next_y, h, w);
            }
        }
        ///////////////////////////////////////////////////////////////////////////
        Graph g;
        //始点sからS回以内の移動でたどりつける町を探索
        void bfs(vec &amp;dist, ll S, ll s)
        {
            queue&lt;ll&gt; que;
            dist[s] = 0;
            que.push(s);
            while (!que.empty())
            {
                ll v = que.front();
                que.pop();
                if (dist[v] == S)
                    continue;
                for (auto next_v : g[v])
                {
                    if (dist[next_v] != -1)
                        continue;
                    dist[next_v] = dist[v] + 1;
                    que.push(next_v);
                }
            }
        }
    </code>
    </pre>
</body>

</html>
